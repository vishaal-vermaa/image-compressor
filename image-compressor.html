<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Image -> 30KB-50KB Compressor</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#9aa6b2; --accent:#60a5fa;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;}
    body{
      margin:0; font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background:linear-gradient(180deg,#071120 0%,#041021 100%); color:#e6eef6;
      display:grid; place-items:center; padding:24px;
    }
    .card{
      width:100%; max-width:820px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:14px; box-shadow: 0 6px 30px rgba(2,6,23,0.7); padding:20px; border:1px solid rgba(255,255,255,0.04);
      display:grid; gap:16px;
    }
    header{display:flex; justify-content:space-between; align-items:center; gap:12px}
    h1{font-size:18px; margin:0; letter-spacing:0.2px}
    p.lead{margin:0; color:var(--muted); font-size:13px}
    .controls{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
    input[type=file]{display:inline-block}
    button{
      background:var(--accent); color:#042033; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600;
      box-shadow: 0 4px 14px rgba(96,165,250,0.12);
    }
    button[disabled]{opacity:0.5; cursor:not-allowed}
    .row{display:flex; gap:12px; align-items:flex-start}
    .preview{
      width:260px; min-height:160px; background:var(--glass); border-radius:10px; padding:10px; display:flex; align-items:center; justify-content:center;
      border:1px dashed rgba(255,255,255,0.04); overflow:hidden; position:relative;
    }
    .info{
      flex:1; display:flex; flex-direction:column; gap:8px;
    }
    .meta{font-size:13px; color:var(--muted)}
    img#previewImg{max-width:100%; max-height:320px; display:block; border-radius:6px}
    .result{
      display:flex; gap:10px; align-items:center;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:8px; padding:10px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .size-pill{background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:6px; font-weight:700}
    .log{font-family:monospace; font-size:12px; color:#cfe9ff; background: rgba(255,255,255,0.01); padding:8px; border-radius:8px; max-height:140px; overflow:auto}
    footer{display:flex; justify-content:space-between; align-items:center; gap:12px}
    .note{font-size:12px; color:var(--muted)}
    .spinner{width:16px;height:16px;border-radius:50%; border:2px solid rgba(255,255,255,0.1); border-top-color:var(--accent); animation:spin 1s linear infinite; display:inline-block}
    @keyframes spin{to{transform:rotate(360deg)}}
    a.download{background:transparent; color:var(--accent); text-decoration:underline; font-weight:600; padding:6px 8px; border-radius:6px}
    @media (max-width:780px){
      .row{flex-direction:column}
      .preview{width:100%}
    }
  </style>
</head>
<body>
  <div class="card" role="main">
    <header>
      <div>
        <h1>Image Compressor — target 30KB–50KB</h1>
        <p class="lead">Select an image and the page will compress it client-side (no upload). Converts to JPEG for best results.</p>
      </div>
      <div class="meta">Target: <strong>30 KB</strong> — <strong>50 KB</strong></div>
    </header>

    <div class="controls">
      <label for="fileInput" class="meta">Select image: </label>
      <input 
        id="fileInput" 
        name="fileInput"
        type="file" 
        accept="image/jpeg,image/png,image/gif,image/webp" 
        required
      >
      <button id="startBtn" disabled>Compress</button>
      <button id="resetBtn" type="button">Reset</button>
      <div id="status" class="meta" aria-live="polite">No image selected</div>
    </div>

    <div class="row">
      <div class="preview" title="Preview area">
        <span id="previewPlaceholder" class="meta">Preview will appear here</span>
        <img id="previewImg" alt="preview" style="display:none">
      </div>

      <div class="info">
        <div class="result">
          <div>
            <div class="meta">Original</div>
            <div id="origSize" class="size-pill">—</div>
          </div>
          <div>
            <div class="meta">Compressed</div>
            <div id="newSize" class="size-pill">—</div>
          </div>
          <div style="margin-left:auto">
            <a id="downloadLink" class="download" href="#" download style="display:none">Download</a>
          </div>
        </div>

        <div class="meta">Dimensions: <span id="dims">—</span></div>

        <div class="log" id="log">Log:</div>
      </div>
    </div>

    <footer>
      <div class="note">Strategy: binary-search quality + downscale until file fits in range. If image cannot reach 30KB, shows best attempt.</div>
      <div id="footerRight"><small class="meta">Client-side only · No data leaves your browser</small></div>
    </footer>
  </div>

  <script>
    // Target size range (bytes)
    const MIN_BYTES = 30 * 1024; // 30 KB
    const MAX_BYTES = 50 * 1024; // 50 KB
    // Minimum dimension to avoid destroying image (px)
    const MIN_DIMENSION = 180;

    const fileInput = document.getElementById('fileInput');
    const previewImg = document.getElementById('previewImg');
    const previewPlaceholder = document.getElementById('previewPlaceholder');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const status = document.getElementById('status');
    const origSizeEl = document.getElementById('origSize');
    const newSizeEl = document.getElementById('newSize');
    const dimsEl = document.getElementById('dims');
    const logEl = document.getElementById('log');
    const downloadLink = document.getElementById('downloadLink');

    let originalFile = null;
    let originalImage = null;

    function log(...args){
      const line = args.map(a => typeof a === 'number' ? a : (typeof a === 'string' ? a : JSON.stringify(a))).join(' ');
      logEl.textContent = logEl.textContent + "\\n" + line;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function humanBytes(n){
      if (n === null || n === undefined) return '—';
      if (n < 1024) return n + ' B';
      if (n < 1024*1024) return (n/1024).toFixed(1) + ' KB';
      return (n/1024/1024).toFixed(2) + ' MB';
    }

    function handleFileSelect(event) {
      try {
        console.log('File input change event triggered');
        
        // Reset the state first
        // resetState();
        
        // Get the files from the input element directly
        const fileInput = event.target;
        const files = fileInput.files;
        
        console.log('Files object:', files);
        console.log('Number of files:', files ? files.length : 0);
        
        if (!files || files.length === 0) {
          console.log('No files selected');
          status.textContent = 'No file selected';
          return;
        }
        
        const selectedFile = files[0];
        console.log('Selected file details:', {
          name: selectedFile.name,
          type: selectedFile.type,
          size: selectedFile.size
        });
        
        if (!selectedFile.type.startsWith('image/')) {
          status.textContent = 'Please select an image file';
          return;
        }
        
        // Store the file and update UI
        originalFile = selectedFile;
        origSizeEl.textContent = humanBytes(selectedFile.size);
        status.textContent = 'Loading image...';
        log('Selected file:', selectedFile.name, humanBytes(selectedFile.size));
        
        // Create and load preview
        const objectUrl = URL.createObjectURL(selectedFile);
        console.log('Created object URL for preview:', objectUrl);
        
        previewImg.onload = function() {
          console.log('Preview image loaded successfully');
          previewPlaceholder.style.display = 'none';
          previewImg.style.display = 'block';
          dimsEl.textContent = previewImg.naturalWidth + ' × ' + previewImg.naturalHeight;
          status.textContent = 'Ready to compress';
          startBtn.disabled = false;
          originalImage = {
            width: previewImg.naturalWidth,
            height: previewImg.naturalHeight,
            url: objectUrl
          };
          log('Image preview loaded:', previewImg.naturalWidth + '×' + previewImg.naturalHeight);
        };
        
        previewImg.onerror = function(error) {
          console.error('Failed to load preview image:', error);
          status.textContent = 'Failed to load image';
          log('Failed to decode image');
          URL.revokeObjectURL(objectUrl);
        };
        
        console.log('Setting preview image source');
        previewImg.src = objectUrl;
        
      } catch (error) {
        console.error('Error handling file:', error);
        status.textContent = 'Error handling file';
        log('Error:', error.message);
      }
    }
    
    fileInput.addEventListener('change', handleFileSelect);

    resetBtn.addEventListener('click', resetState);

    function resetState(){
      startBtn.disabled = true;
      fileInput.value = '';
      previewImg.src = '';
      previewImg.style.display = 'none';
      previewPlaceholder.style.display = 'block';
      originalFile = null;
      originalImage = null;
      status.textContent = 'No image selected';
      origSizeEl.textContent = '—';
      newSizeEl.textContent = '—';
      dimsEl.textContent = '—';
      logEl.textContent = 'Log:';
      downloadLink.style.display = 'none';
      if (previewImg.src) try{ URL.revokeObjectURL(previewImg.src); }catch(e){}
    }

    startBtn.addEventListener('click', async () => {
      if (!originalFile || !originalImage) return;
      startBtn.disabled = true;
      resetBtn.disabled = true;
      status.innerHTML = '<span class="spinner" aria-hidden="true"></span> Compressing...';
      log('Compression started. Target range:', MIN_BYTES, '-', MAX_BYTES, 'bytes');

      try{
        const best = await compressToTarget(originalImage, originalFile);
        if (!best) {
          status.textContent = 'Compression failed';
          log('No output produced.');
          startBtn.disabled = false;
          resetBtn.disabled = false;
          return;
        }
        newSizeEl.textContent = humanBytes(best.blob.size);
        status.textContent = `Done — ${humanBytes(best.blob.size)} (${best.width}×${best.height}, q=${best.quality.toFixed(2)})`;
        log('Finished. Final size:', best.blob.size, 'bytes');
        // create download link
        const outURL = URL.createObjectURL(best.blob);
        downloadLink.href = outURL;
        // filename: originalname-compressed.jpg
        const base = (originalFile && originalFile.name) ? originalFile.name.replace(/\\.[^/.]+$/, "") : 'image';
        downloadLink.download = base + '-compressed.jpg';
        downloadLink.style.display = 'inline';
      } catch(err){
        console.error(err);
        log('Error:', err && err.message ? err.message : err);
        status.textContent = 'Error during compression: ' + (err && err.message ? err.message : '');
      } finally {
        startBtn.disabled = false;
        resetBtn.disabled = false;
      }
    });

    // Main function: attempts to compress image to target range.
    async function compressToTarget(imgInfo, fileObj){
      // Get an HTMLImageElement for the selected file (we already have previewImg loaded).
      const imgEl = previewImg; // already loaded
      // Start with original dimensions but may downscale
      let width = imgEl.naturalWidth;
      let height = imgEl.naturalHeight;

      // If original file already fits in range and is JPEG, we can simply return original or re-encode at high quality to ensure JPEG format
      if (fileObj.size >= MIN_BYTES && fileObj.size <= MAX_BYTES){
        log('Original file already within desired range.');
        // ensure it's JPEG — if not, re-encode at max quality to keep format consistent
        if (fileObj.type === 'image/jpeg' || fileObj.type === 'image/jpg'){
          return { blob: fileObj, width, height, quality: 1 };
        } else {
          const blob = await drawAndBlob(imgEl, width, height, 0.92);
          return { blob, width, height, quality: 0.92 };
        }
      }

      // binary search quality at current dimensions
      async function findByQuality(targetMax){
        let low = 0.06, high = 0.97, bestBlob = null, bestQuality = low;
        for (let i=0;i<8;i++){
          const mid = (low + high) / 2;
          const blob = await drawAndBlob(imgEl, width, height, mid);
          log(`try q=${mid.toFixed(3)} -> ${blob.size} bytes`);
          if (blob.size > targetMax) {
            // too big -> reduce quality
            high = mid;
          } else {
            // fits under target -> try higher quality to improve quality while staying under
            bestBlob = blob; bestQuality = mid;
            low = mid;
          }
        }
        return bestBlob ? { blob: bestBlob, quality: bestQuality } : null;
      }

      // Step 1: Try binary search on quality at original dimensions
      log('Phase 1: adjust quality only (no resizing).');
      let attempt = await findByQuality(MAX_BYTES);
      if (attempt && attempt.blob.size >= MIN_BYTES && attempt.blob.size <= MAX_BYTES){
        log('Success without resizing.');
        return { blob: attempt.blob, width, height, quality: attempt.quality };
      }
      // If attempt exists but is smaller than MIN_BYTES -> it undershot; but that's okay if it's within upper bound. We'll prefer sizes within range.
      if (attempt && attempt.blob.size <= MAX_BYTES && attempt.blob.size >= MIN_BYTES){
        return { blob: attempt.blob, width, height, quality: attempt.quality };
      }

      // Step 2: Progressive downscale + quality search
      log('Phase 2: progressive downscale + quality search.');
      let lastGood = null;
      // We'll reduce dimensions gradually (e.g., 90% steps) until we get within range or hit MIN_DIMENSION.
      let scaleFactor = 0.92;
      let attemptsCount = 0;
      while (Math.min(width, height) > MIN_DIMENSION && attemptsCount < 12){
        // reduce size
        width = Math.round(width * scaleFactor);
        height = Math.round(height * scaleFactor);
        attemptsCount++;
        log('Downscale to', width, 'x', height);
        // try find best quality at these dimensions
        let res = await findByQuality(MAX_BYTES);
        if (res){
          log('Found candidate at', width, 'x', height, 'size:', res.blob.size);
          if (res.blob.size >= MIN_BYTES && res.blob.size <= MAX_BYTES){
            return { blob: res.blob, width, height, quality: res.quality };
          }
          // If it's under MIN_BYTES but still close, keep as lastGood (we prefer closer to range but not over)
          if (!lastGood || Math.abs(res.blob.size - ((MIN_BYTES+MAX_BYTES)/2)) < Math.abs(lastGood.blob.size - ((MIN_BYTES+MAX_BYTES)/2))){
            lastGood = { blob: res.blob, width, height, quality: res.quality };
          }
        } else {
          // if not found, try directly creating a low-quality blob to see final size
          const lowQ = await drawAndBlob(imgEl, width, height, 0.06);
          log('Fallback lowQ size', lowQ.size, 'at', width + 'x' + height);
          if (!lastGood || Math.abs(lowQ.size - ((MIN_BYTES+MAX_BYTES)/2)) < Math.abs(lastGood.blob.size - ((MIN_BYTES+MAX_BYTES)/2))){
            lastGood = { blob: lowQ, width, height, quality: 0.06 };
          }
          // if lowQ fits within range, return it
          if (lowQ.size >= MIN_BYTES && lowQ.size <= MAX_BYTES){
            return { blob: lowQ, width, height, quality: 0.06 };
          }
        }
        // Next iteration: continue downscaling
        // slightly reduce scaleFactor to be more aggressive if not getting closer
        if (attemptsCount === 6) scaleFactor = 0.85;
      }

      // Step 3: final attempts — try extreme downscale to small dimensions
      if (!lastGood){
        log('Phase 3: extreme downscale attempts.');
        const targetWidths = [800, 600, 480, 360, 300, 240, 200];
        for (const w of targetWidths){
          if (w >= originalImage.width) continue;
          const h = Math.round((originalImage.height / originalImage.width) * w);
          const blob = await drawAndBlob(imgEl, w, h, 0.06);
          log('extreme', w+'x'+h, '->', blob.size);
          if (!lastGood || Math.abs(blob.size - ((MIN_BYTES+MAX_BYTES)/2)) < Math.abs(lastGood.blob.size - ((MIN_BYTES+MAX_BYTES)/2))){
            lastGood = { blob, width: w, height: h, quality: 0.06 };
          }
          if (blob.size >= MIN_BYTES && blob.size <= MAX_BYTES){
            return { blob, width: w, height: h, quality: 0.06 };
          }
        }
      }

      // If we reach here, we couldn't hit the exact range. Return the best candidate (closest to mid point).
      if (lastGood){
        log('Returning best-effort result (closest to target). Final size:', lastGood.blob.size);
        return lastGood;
      }

      // As a last fallback, return re-encoded original at low quality
      const fallback = await drawAndBlob(imgEl, Math.max(200, Math.round(originalImage.width * 0.5)), Math.max(200, Math.round(originalImage.height * 0.5)), 0.06);
      log('Fallback final size:', fallback.size);
      return { blob: fallback, width: fallback.width, height: fallback.height, quality: 0.06 };
    }

    // draw image on canvas and return a Promise<Blob>
    function drawAndBlob(imgEl, targetW, targetH, quality){
      return new Promise((resolve, reject) => {
        try{
          // create canvas
          const canvas = document.createElement('canvas');
          canvas.width = Math.max(1, targetW);
          canvas.height = Math.max(1, targetH);
          const ctx = canvas.getContext('2d');
          // clear
          ctx.clearRect(0,0,canvas.width,canvas.height);
          // draw with high-quality scaling
          // Use imageSmoothing for better downscale quality
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(imgEl, 0, 0, canvas.width, canvas.height);
          // convert to blob (JPEG)
          canvas.toBlob(blob => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }catch(err){
          reject(err);
        }
      });
    }

  </script>
</body>
</html>
